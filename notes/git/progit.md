# Git 简介

- 相对其他版本控制的差异

git是直接快照,而非记录的比较差异.Git 和其他版本控制系统的主要差别在于,Git 只关心文件数据的整体是否发生变化,而大多数其他系统则只关心文件内容的具体差异.

- 可以不联网提交

git基本上所有的操作都是可以在本地完成的,本地的操作对象是和服务器端的是一样的拷贝.

- 保持数据的完整性

在保存到 Git 之前,所有数据都要进行内容的校验和(checksum)计算,并将此结果作为数据的唯一标识和索引。换
句话说,不可能在你修改了文件或目录之后,Git 一无所知。git中的所有操作都是根据这个索引值来的,而不是靠文件名.

- git中数据的三种状态

一个文件,在 Git 内都只有三种状态:已提交(committed),已修改(modified)和已暂存(staged)。

- 基本的 Git 工作流程如下所示:
1. 在工作目录中修改某些文件。
2. 对这些修改了的文件作快照,并保存到暂存区域。
3. 提交更新,将保存在暂存区域的文件快照转储到 git 目录中。

# git安装

## git配置
git-config 命令可以进行git配置.

配置文件的位置分为三个地方

-  etc/gitconfig文件:系统中对所有用户都普遍适用的配置。若使用 git config 时用 --system 选项,读写的就是这个文件。
- ~/.gitconfig文件:用户目录下的配置文件只适用于该用户。若使用 git config 时用 --global 选项,读写的就是这个文件。
- 当前项目的 git 目录中的配置文件(也就是工作目录中的 .git/config 文件):这里的配置仅仅针对当前
项目有效。

对于每一个级别的配置都会覆盖上层的相同配置,所以 .git/config 里的配置会覆盖 /etc/gitconfig 中的同名变量。


```shell
$ git config --global user.name "John Doe"
$ git config --global user.email johndoe@example.com
```
如果用了 --global 选项,那么更改的配置文件就是位于你用户主目录下的那个,以后你所有的项目都会默认使用这
里配置的用户信息。如果要在某个特定的项目中使用其他名字或者电邮,只要去掉 --global 选项重新配置即可,新
的设定保存在当前项目的 .git/config 文件里。

```shell
$ git config --global core.editor emacs
```
可以设置文本编辑器

```shell
$ git config --global merge.tool vimdiff
```
可以设置差异分析工具

```shell
$ git config --list
```
检查已有的配置信息.

```shell
$git config user.name
```
检查指定设置的内容

## 获取帮助内容
```shell
git help <verb>
git <verb> --help
man git-<verb>
```


# git 基础

## 获取仓库

通过初始化的方式
```shell
$git init
```
```shell
git clone respsite
```
## 检查当前文件状态

```shell
git status
```
## 跟踪新文件
```shell
git add filepath
```

## 暂存已修改的文件
通过git add 命令将修改过的文件添加到暂存区域.
git add 命令是个多功能命令：可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等。
所以，理解成将文件添加到下次提交。

## 忽略某些文件
文件 .gitignore 的格式规范如下:
- 所有空行或者以注释符号 # 开头的行都会被 Git 忽略。
- 可以使用标准的 glob 模式匹配。
- 匹配模式最后跟反斜杠(/)说明要忽略的是目录。
- 要忽略指定模式以外的文件或目录,可以在模式前加上惊叹号(!)取反。
所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。星号(*)匹配零个或多个任意字符;[abc] 匹配任何一
个列在方括号中的字符(这个例子要么匹配一个 a,要么匹配一个 b,要么匹配一个 c);问号(?)只匹配一个任意
字符;如果在方括号中使用短划线分隔两个字符,表示所有在这两个字符范围内的都可以匹配(比如 [0-9] 表示匹配
所有 0 到 9 的数字)。
我们再看一个 .gitignore 文件的例子:
\# 此 为 注 释
*.a        # 忽略所有 .a 结 尾的文件
!lib.a     # 但 lib.a 除外
/TODO # 仅仅忽略项目根目录下的TODO文件,不包括subdir/TODO
build/    # 忽略build/目录下的所有文件
doc/*.txt # 忽略doc/notes.text但是不包括doc/server/arch.txt

## 查看已暂存和未暂存的更新

git status 显示的比较简单,只是列出了修改过的文件,想要查看具体的修改,可以使用git diff.

git diff 比较的是工作区域中更改了，还未提交到暂存区域的文件和暂存区域之间的差异。
git diff --cached查看已经提交到暂存区中，等待提交的内容。

## 提交更新
git commit 这个会启动一个编辑命令,让你输入输入提交信息.
git commit -m 提交记录和输入提交信息一起完成.
git commit -a -m "message" git 会跳过缓存区,直接将符合git跟踪的文件一并提交了.但这个命令方式只适合那些修改的文件,不适合新增的文件.

## 移除文件

git rm file从已经跟踪的文件清单中移除,然后提交,完成远程仓库的也被移除.
如该仅仅是从文件系统中删除,git status会有提示,需要进行rm操作.

如果删除之前修改过并且已经放到暂存区域的话,则必须要用强制删除选项 -f(译注:即 force 的首字母),以防误删除文件后丢失修改的内容

对于想把文件从 Git 仓库中删除(亦即从暂存区域移除),但仍然希望保留在当前工作目录中。换句话说,仅是从跟踪清单中删除。比如一些大型日志文件或者一堆 .a 编译文件,不小心纳入仓库后,要移除跟踪但
不删除文件,以便稍后在 .gitignore 文件中补上,用 --cached 选项即可:
```shell
$ git rm --cached readme.txt
```shell

后面可以列出文件或者目录的名字,也可以使用 glob 模式。比方说:
$ git rm log/\*.log
注意到星号 * 之前的反斜杠 \,因为 Git 有它自己的文件模式扩展匹配方式,所以我们不用 shell 来帮忙展开(译注:实际上不加反斜杠也可以运行,只不过按照 shell 扩展的话,仅仅删除指定目录下的文件而不会递归匹配。上面的
例子本来就指定了目录,所以效果等同,但下面的例子就会用递归方式匹配,所以必须加反斜杠。)。此命令删除所有 log/ 目录下扩展名为 .log 的文件。类似的比如:
$ git rm \*~
会递归删除当前目录及其子目录中所有 ~ 结尾的文件。

## 移动文件
如果在 Git 中重命名了某个文件，仓库中存储的元数据并不会体现出这是一次改名操作。

```shell
$ git mv file_from file_to
```
这个命令等价于

```shell
$ mv README.md README
$ git rm README.md
$ git add README
```

## 查看提交历史

```shell
$ git log
```
查看相对详细的信息，列出每个提交的 SHA-1 校验和、作者的名字和电子邮件地址、提交时间以及提交说明。

```shell
$ git log -p -2
```
显示每次提交的内容差异。 你也可以加上 -2 来仅显示最近两次提交：该选项除了显示基本信息之外，还在附带了每次 commit 的变化。

```shell
$ git log --stat
```
该选项显示每次提交的简略的统计信息。列出额所有被修改过的文件、有多少文件被修改了以及被修改过的文件的哪些行被移除或是添加了。

```shell
$ git log --pretty=oneline
```
--pretty。 这个选项可以指定使用不同于默认格式的方式展示提交历史。这里的oneline表示以一行的形式显示出来。这个选项有一些内建的子选项供你使用。 比如用 oneline 将每个提交放在一行显示，查看的提交数很大时非常有用。 另外还有 short，full 和 fuller 可以用，展示的信息或多或少有些不同。

```shell
$ git log --pretty=format:"%h - %ah , %ar : %s"
```
format可以用来定制需要显示的log的格式.

- 常用的选项如下:

%H
提交对象（commit）的完整哈希字串
%h
提交对象的简短哈希字串
%T
树对象（tree）的完整哈希字串
%t
树对象的简短哈希字串
%P
父对象（parent）的完整哈希字串
%p
父对象的简短哈希字串
%an
作者（author）的名字
%ae
作者的电子邮件地址
%ad
作者修订日期（可以用 --date= 选项定制格式）
%ar
作者修订日期，按多久以前的方式显示
%cn
提交者(committer)的名字
%ce
提交者的电子邮件地址
%cd
提交日期
%cr
提交日期，按多久以前的方式显示
%s
提交说明

```shell
$ git log --pretty=format:"%h  % s" --graph
```
这个选项添加了一些ASCII字符串来形象地展示你的分支、合并历史.

git log 常用的选项
-p
按补丁格式显示每个更新之间的差异。
--stat
显示每次更新的文件修改统计信息。
--shortstat
只显示 --stat 中最后的行数修改添加移除统计。
--name-only
仅在提交信息后显示已修改的文件清单。
--name-status
显示新增、修改、删除的文件清单。
--abbrev-commit
仅显示 SHA-1 的前几个字符，而非所有的 40 个字符。
--relative-date
使用较短的相对时间显示（比如，“2 weeks ago”）。
--graph
显示 ASCII 图形表示的分支合并历史。
--pretty
使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式）。

-- 限制输出长度
限制log的个数呢,其实用处没那么大,因为git在输出log的时候,已经有调用分页的功能.另外一个比较人性化的地方是可以类似于DQL似的查询(我自己这么说的).

``shell
﻿$ git log --since=2.weeks
$ git log --since="2016-11-11"
$ git log --before="2016-11-11"
$ git log --since=1.weeks --grep "hello" //提交的说明里面有hello
$ git log -SGroupViewHolder // 搜出某次提交的内容中有字符串GroupViewHolder的提交
```

限制 git log 输出的选项

-(n)
仅显示最近的 n 条提交
--since, --after
仅显示指定时间之后的提交。
--until, --before
仅显示指定时间之前的提交。
--author
仅显示指定作者相关的提交。
--committer
仅显示指定提交者相关的提交。
--grep
仅显示含指定关键字的提交
-S
仅显示添加或移除了某个关键字的提交


## 撤销操作
在操作的任何一个阶段,你都有可能有想要撤销的某些操作.有点撤销操作是不可逆的,比较少见.

```shell
$ git commit -m 'initial commit'
$ git add forgotten_file
$ git commit --amend
```
提交完了才发现**漏掉**了几个文件没有添加，或者提交**信息写错**了。 此时，可以运行带有 --amend 选项的提交命令尝试重新提交.
这个命令会将暂存区中的文件提交。 如果自上次提交以来你还未做任何修改（例如，在上次提交后马上执行了此命令），那么快照会保持不变，而你所修改的只是提交信息。
文本编辑器启动后，可以看到之前的提交信息。 编辑后保存会覆盖原来的提交信息。
最终你只会有一个提交 - 第二次提交将代替第一次提交的结果。



```shell
$ git checkout filepath
```
撤消对文件的修改,这个命令可以实现对工作区内容的抛弃.

## 查看远程仓库(请结合分支理解)
```shell
$ git remote
$ git remote -v

```
这样可以查看当前的仓库对应的远程仓库.

```shell
git remote add origin git@git.oschina.net:genggeng/HelloWorld.git
```
这种情况下,可以实现每个分支对应不同的远程仓库.

```shell
$ git fetch origin
```
使用 clone 命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以 “origin” 为简写。
必须注意 git fetch 命令会将数据拉取到你的本地仓库 - 它并不会自动合并或修改你当前的工作。 当准备好时你必须手动将其合并入你的工作。

如果你有一个分支设置为跟踪一个远程分支，可以使用 git pull 命令来自动的抓取然后合并远程分支到当前分支。

默认情况下，git clone 命令会自动设置**本地 master 分支**跟踪克隆的**远程仓库的 master 分支**（或**不管是什么名字的默认分支**）。 运行 git pull 通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。


```shell
$ git push origin master
```
命令 git push [remote-name] [branch-name]实现上传代码至远程仓库.

能够推送代码有两个必备的前提:
- 有仓库的写入权限
- 在这之前没有人推送提交


```shell
$ git remote show origin
```
查看某一个远程仓库的更多信息.会将远程仓库的地址,分支,以及分支是否被tracker都列出.
这个命令列出了当你在特定的分支上执行 git push 会自动地推送到哪一个远程分支。 它也同样地列出了哪些远程分支不在你的本地，哪些远程分支已经从服务器上移除了，还有当你执行 git pull 时哪些分支会自动合并.


```shell
$ git remote rename origin re
```
这样可以实现对远程仓库的重命名.需要注意,这同样也会修改你的远程分支名字。 那些过去引用 origin/master 的现在会引用 re/master。


```shell
$ git remote rm re
```
实现远程仓库的删除.


# tag 标签
```shell
$ git tag
```
这个可以列出所有的标签.

```shell
$ git tag -l 'lvmama_7*'
```
只对部分的tag感兴趣就可以这样去查找.


- 轻量标签
一个轻量标签很像一个不会改变的分支 - 它只是一个特定提交的引用。
```shell
git tag v781
```
这样就可以创建一个轻量的标签.
- 附注标签,annotated
附注标签是存储在 Git 数据库中的一个完整对象。 它们是可以被校验的；其中包含打标签者的名字、电子邮件地址、日期时间；还有一个标签信息；
```shell
$ git tag -a v781 -m '781'
```
这样可以创建一个附注标签.

```shell
$ git show v781
```
这样可以展示除具体的tag信息,如该是附注的标签,可以看到原先提交的信息.

```shell
$ git tag -a v781 SHA-1
```
这样可以实现事后打标签的功能.

```shell
$ git push origin v781
$ git push origin --tags
```
这样可以实现将tag推送到远端的仓库中.


```shell
$ git checkout -b branchV781 v781
```
在 Git 中你并不能真的检出一个标签，因为它们并不能像分支一样来回移动。 如果你想要工作目录与仓库中特定的标签版本完全一样，可以使用 git checkout -b [branchname] [tagname] 在特定的标签上创建一个新分支

通常使用的是附注标签.


# Git别名
暂时不学.




# 分支
把你的工作从开发主线上分离开来，以免影响开发主线。很多其他的版本控制系统都是直接复制的一份副本.比较低效.
Git 鼓励在工作流程中频繁地使用分支与合并.
Git 保存的不是文件的变化或者差异，而是一系列不同时刻的文件快照。
在进行提交操作时，Git 会保存一个提交对象（commit object）。知道了 Git 保存数据的方式，我们可以很自然的想到——该提交对象会包含一个指向暂存内容快照的指针。


暂存操作会为每一个文件计算校验和（使用我们在 Chapter 1 中提到的 SHA-1 哈希算法），然后会把当前版本的文件快照保存到 Git 仓库中（Git 使用 blob 对象来保存它们），最终将校验和加入到暂存区域等待提交.
当使用 git commit 进行提交操作时，Git 会先计算每一个子目录的校验和，然后在 Git 仓库中这些校验和保存为树对象。 随后，Git 便会创建一个提交对象，它除了包含上面提到的那些信息外，还包含指向这个树对象（项目根目录）的指针。如此一来，Git 就可以在需要的时候重现此次保存的快照。


Git 的分支，其实本质上仅仅是指向提交对象的可变指针。它会在每次的提交操作中自动向前移动。

```shell
$ git branch dev
```
这样就可以创建一个dev分支.这会在当前所在的提交对象上创建一个指针dev。


Git 怎么知道当前在哪一个分支上呢？ 也很简单，它有一个名为 HEAD 的特殊指针。指向当前所在的本地分支(指针).


```shell
$ git log --oneline --decorate
```
查看各个分支当前所指的对象。已经当前HEAD所指的分支指针.

```shell
$ git checkout dev
```
这样可以实现分支的切换.这样 HEAD 就指向 dev 分支了。

Git 的分支实质上仅是包含 **所指对象校验和**（长度为 40 的 SHA-1 值字符串）的文件，所以它的创建和销毁都异常高效。 创建一个新分支就像是往一个文件中写入 41 个字节（40 个字符和 1 个换行符），如此的简单能不快吗？
这与过去大多数版本控制系统形成了鲜明的对比，它们在创建分支时，将所有的项目文件都复制一遍，并保存到一个特定的目录。 完成这样繁琐的过程通常需要好几秒钟，有时甚至需要好几分钟。所需时间的长短，完全取决于项目的规模。而在 Git 中，任何规模的项目都能在瞬间创建新分支。 同时，由于每次提交都会记录父对象，所以寻找恰当的合并基础（译注：即共同祖先）也是同样的简单和高效。 这些高效的特性使得 Git 鼓励开发人员频繁地创建和使用分支。


```shell
$ git checkout -b bug
```

```shell
$ git branch bug
$ git checkout bug
```

这个是新建一个bug分支.并且切换新的分支.

```shell
$ git checkout master
$ git merge bug
```
这样可以将bug分支合并到master分支.
当master所指的提交是当前bug的直接上游,那么master则直接简单的将指针向前移动即可.
当试图合并两个分支的时候,如果顺着一个分支走下去能够到达另一个分支,则在合并的时候,只是简单的将指针向前推进即可.这个也就是所谓的fast-forward.

大部分情况下,并不能这么完美,是一个分叉的结构.这时候,就会需要做些额外的工作.
这个时候,git会使用待合并的两个分支的末端,以及两个分支的最近的共同祖先,做一个简单的三方合并.

和之前将分支指针向前推进所不同的是，Git 将此次三方合并的结果做了一个新的快照并且自动创建一个新的提交指向它。 这个被称作一次合并提交，它的特别之处在于他有不止一个父提交。


```shell
$ git branch -d bug
```
对于无用的分支,可以这样删除.


```java
<<<<<<< HEAD:
//当前分支的改动

=======
// bug分支也改动了
>>>>>>> bug

```
对于冲突的内容会以这种形式展现.

当解决完这些冲突之后,执行 add 命令,标记解决,然后执行 commit 命令提交,即可完成冲突的解决.默认的提交信息标明了冲突的文件.

在解决冲突的过程当中,如果想用图形化的工具解决,则执行以下命令:
```shell
$ git mergetool
```
前提是需要实现配置了相关的工具.


```shell
$ git branch
```
这个命令会列出当前所处的分支.会以星号*标识出来.

```shell
$ git branch -v
```
查看每一个分支的最后一次提交.

```
$ git branch --merged
```
查看哪些分支已经合并到当前分支;

```shell
$ git branch --no-merged
```
哪些分支没有合并到当前的分支.

对于那些没有被合并的分支,在删除的时候,会提示的,会删除失败,想要删除就需要进行强制删除.


### 工作流 (需要再整合)
因为 Git 使用简单的三方合并，所以就算在一段较长的时间内，反复把一个分支合并入另一个分支，也不是什么难事。 也就是说，在整个项目开发周期的不同阶段，你可以同时拥有多个开放的分支；你可以定期地把某些特性分支合并入其他分支中。

特性分支:这项技术能使你快速并且完整地进行上下文切换（context-switch）——因为你的工作被分散到不同的流水线中，在不同的流水线中每个分支都仅与其目标特性相关，因此，在做代码审查之类的工作的时候就能更加容易地看出你做了哪些改动。

### 远程分支

**远程引用**是对**远程仓库**的引用（指针），包括分支、标签等等。

**远程跟踪分支**是**远程分支**状态的引用。 它们是你不能移动的本地引用，当你做任何网络通信操作时，它们会自动移动。 远程跟踪分支像是你上次连接到远程仓库时，那些分支所处状态的书签。
它们以 (remote)/(branch) 形式命名。

- orgin并无特殊含义
远程仓库名字 “origin” 与分支名字 “master” 一样，在 Git 中并没有任何特别的含义一样。 同时 “master” 是当你运行 git init 时默认的起始分支名字，原因仅仅是它的广泛使用，“origin” 是当你运行 git clone 时默认的远程仓库名字。 如果你运行 git clone -o booyah，那么你默认的远程分支名字将会是 booyah/master。


> 在本地的 master 分支做了一些工作，然而在同一时间，其他人推送提交到 git.ourcompany.com 并更新了它的 master 分支，那么你的提交历史将向不同的方向前进。 也许，只要你不与 origin 服务器连接，你的 origin/master 指针就不会移动.
> 如果要同步你的工作，运行 git fetch origin 命令。 这个命令查找 “origin” 是哪一个服务器（在本例中，它是 git.ourcompany.com），从中抓取本地没有的数据，并且更新本地数据库，移动 origin/master 指针指向新的、更新后的位置。


```shell
$ git push origin master
$ git push (remote) (branch):
```
这样可以将本地的master 分支推送到远程仓库对应的master分支.前提是有相应的写入权限.
Git 自动将 master 分支名字展开为 refs/heads/master:refs/heads/master.
推送本地的 master 分支来更新远程仓库上的 master 分支。
git push origin branch1:branch2 来将本地的 branch1 分支推送到远程仓库上的 branch2 分支。

- 如何避免每次输入密码
如果你正在使用 HTTPS URL 来推送，Git 服务器会询问用户名与密码。 默认情况下它会在终端中提示服务器是否允许你进行推送。
如果不想在每一次推送时都输入用户名与密码，你可以设置一个 “credential cache”。 最简单的方式就是将其保存在内存中几分钟，可以简单地运行 git config --global credential.helper cache 来设置它。


```shell
$ git push origin dev
```
下一次其他协作者执行 fetch 指令从服务器上抓取数据时，他们会在本地生成一个远程分支 origin/dev，指向服务器的 dev 分支的引用.但是本地并不会自动生成对应的本地分支，只会有这个不能更改的跟踪指针。

```shell
$ git merge origin/dev
$ git checkout -b dev origin/dev
```

对这个远程分支，可以采用 merge 指令将其合并到当前分支，或者直接另外建立一个基于这个远程分支的本地分支。

从一个远程跟踪分支检出一个本地分支会自动创建一个叫做“跟踪分支”（有时候也叫做 “上游分支”）。 跟踪分支是与远程分支有直接关系的本地分支。


```shell
$ git checkout --track origin/serverfix
```
可以修改分支的跟踪的远程分支。

```shell
$ git branch -u origin/serverfix
```
通过这个命令，我们可以修改跟踪的远程分支。

> 当设置好跟踪分支后，可以通过 @{upstream} 或 @{u} 快捷方式来引用它。 所以在 master 分支时并且它正在跟踪 origin/master 时，如果愿意的话可以使用 git merge @{u} 来取代 git merge origin/master。










